# 任务  
帮我写微信小游戏代码，小游戏主要玩法是允许用户画一条鱼然后将其放入鱼缸。

# 要求  
1. 代码简洁、可靠、健壮，添加必要的打印监控代码状态，并且保证代码可运行。  
2. 用game.js和game.json实现。  
3. 逐个给出每个程序脚本，不要缺失任何文件，保证项目可运行。   
4. 每个button规格统一为长80像素高40像素，除非要求特殊处理。     
5. 利用代码内置风格统一美化所有组件。  

# 小游戏UI和Button设计    
首先游戏界面整体背景为白色，以手机屏幕竖直状态运行，顶部空出80个像素高度用来避开手机的通知栏。
## 首页部分的整体UI由上到下是功能区、指示区、绘画区、得分区、跳转区。
1. 功能区包含3个part，每个part高度60像素，纵向排列。part1 从左到右依次是7个圆圈按键（直径大小30像素，外框黑色描边，内部颜色分别是黑色、红色、绿色、紫色、黄色、橘色、白色，支持用户选择不同颜色绘画），水平居中均匀分开。part2 左边首先显示文本"Size："，然后是一个滑动控件，用来调节橡皮擦和画笔的粗细。part3 从左到右首先是Eraser的button（橡皮擦）支持用户擦除某区域，然后是Undo的button支持用户一笔笔撤销刚刚的绘画笔迹，再然后是Clear的button支持用户直接清空绘画区域，最后是Flip的button支持用户将绘画左右翻转。四个按键水平居中均匀分开。
2. 指示区占80个像素高度，只包含有两行文本，第一行是 "画一条鱼吧!"，第二行是"鱼头请朝右"， 两行文本字体一致，文本高度均为35像素，布局水平居中。
3. 绘画区由矩形构成，允许用户在矩形内作画，矩形区域高220像素，宽度距离屏幕两边各10像素。
4. 得分区占50个像素高，中间有一行文本"AI评分：0"，文本高度占30像素。
5. 跳转区占60个像素高，从左到右有首先是"鱼缸"的button；然后是"让它游起来！" 的button；最后是"排行榜"的button，这三个button水平居中均匀分开，功能暂时不去实现。





这是我的小游戏代码，请你帮我继续优化下。首先保持原代码主体不变，然后代码风格延续简洁、可靠、健壮、有打印核心步骤信息，最后返回优化后的完整代码。
帮我实现，当用户画完一笔后，将画布的绘画借助canvas.toDataURL()获取base64数据，然后调用大模型api获得ai判断的得分，然后将得分在“AI评分”文本这里打印出来。注意在调用大模型api打分的时候要异步执行，不要耽误用户后续绘画。大模型api的使用demo如下






这是我的小游戏代码，请你帮我继续优化下。首先保持原代码主体不变，然后代码风格延续简洁、可靠、健壮，最后返回优化后的完整代码。
能美化下我现在代码里的所有组件吗，让ui看起来更高级




这是我的小游戏代码，请你帮我继续优化下。首先保持原代码主体不变，然后代码风格延续简洁、可靠、健壮，最后返回优化后的完整代码。
能将这个代码逻辑分为几个脚本吗，重新整理下项目结构，让主程序变得更轻盈，各个功能能在主脚本里实现插拔式的解耦模式。给我拆解后的目录和对应代码。不要拆解成太多，根据主要功能拆解成3、4个脚本就行









canvasToTempFilePath
canvasGetImageData


我在开发一款小游戏，核心玩法是允许用户画一条鱼，然后通过代码生成模拟鱼游动的渲染动画，最后放入鱼缸。
附件是我小游戏代码涉及的所有脚本，请你帮我继续优化下，保持原代码主体不变，代码风格延续简洁、可靠、健壮，最后返回优化后的完整代码。
用户点击“让它游起来”的button实现下面的逻辑，首先判断大模型api返回的得分是否大于60分，如果不满足条件弹出提示“AI评分小于60，这鱼画的太抽象”，如果满足条件计算用户绘制的鱼最小外接矩形，根据这个矩形将用户绘制的作品裁剪出来成为子图，然后将子图的长边对齐到50像素，同时宽边等比例缩放，缩放之后我们称新的图为“缩放图”，获得缩放图之后跳转到新的界面，新的界面我们称之为“公共鱼缸”，尺寸与手机屏幕尺寸对齐，背景为水蓝色，然后再公共鱼缸界面参考下面“游动demo”逻辑，将这个逻辑应用到缩放图上，渲染用户绘画的鱼在公共鱼缸里游动的画面，设置返回键，点击返回键返回到上一级界面。游动demo：// 微信小游戏版鱼游动效果



const FISH_CONFIG = {
  width: 80,
  height: 48,
  speed: 2,
  amplitude: 24,
  peduncle: 0.4
};

class Fish {
  constructor(image, x, y, direction = 1) {
    this.image = image;
    this.x = x;
    this.y = y;
    this.direction = direction;
    this.phase = Math.random() * Math.PI * 2;
    this.amplitude = FISH_CONFIG.amplitude;
    this.speed = FISH_CONFIG.speed;
    this.vx = this.speed * this.direction * 0.1;
    this.vy = (Math.random() - 0.5) * 0.5;
    this.width = FISH_CONFIG.width;
    this.height = FISH_CONFIG.height;
    this.peduncle = FISH_CONFIG.peduncle;
    this.tailEnd = Math.floor(this.width * this.peduncle);
  }

  update(canvasWidth, canvasHeight) {
    this.x += this.vx;
    this.y += this.vy;

    if (this.x <= 0) {
      this.x = 0;
      this.direction = 1;
      this.vx = Math.abs(this.vx);
    } else if (this.x >= canvasWidth - this.width) {
      this.x = canvasWidth - this.width;
      this.direction = -1;
      this.vx = -Math.abs(this.vx);
    }

    if (this.y <= 0) {
      this.y = 0;
      this.vy = Math.abs(this.vy) * 0.5;
    } else if (this.y >= canvasHeight - this.height) {
      this.y = canvasHeight - this.height;
      this.vy = -Math.abs(this.vy) * 0.5;
    }

    this.vx *= 0.85;
    this.vy *= 0.85;

    if (Math.abs(this.vx) < 0.1) {
      this.vx = this.speed * this.direction * 0.1;
    }
  }

  draw(ctx, time) {
    const swimY = this.y + Math.sin(time + this.phase) * this.amplitude;
    this.drawWigglingFish(ctx, this.x, swimY, this.direction, time);
  }

  drawWigglingFish(ctx, x, y, direction, time) {
    const w = this.width;
    const h = this.height;

    for (let i = 0; i < w; i++) {
      let isTail, t, wiggle, drawCol, drawX;

      if (direction === 1) {
        isTail = i < this.tailEnd;
        t = isTail ? (this.tailEnd - i - 1) / (this.tailEnd - 1) : 0;
        wiggle = isTail ? Math.sin(time * 3 + this.phase + t * 2) * t * 12 : 0;
        drawCol = i;
        drawX = x + i + wiggle;
      } else {
        isTail = i >= w - this.tailEnd;
        t = isTail ? (i - (w - this.tailEnd)) / (this.tailEnd - 1) : 0;
        wiggle = isTail ? Math.sin(time * 3 + this.phase + t * 2) * t * 12 : 0;
        drawCol = w - i - 1;
        drawX = x + i - wiggle;
      }

      ctx.save();
      ctx.translate(drawX, y);
      ctx.drawImage(this.image, drawCol, 0, 2, h, 0, 0, 2, h);
      ctx.restore();
    }
  }
}

class FishTank {
  constructor() {
    this.fishes = [];
    this.canvas = null;
    this.ctx = null;
    this.fishImage = null;
  }

  init() {
    this.canvas = wx.createCanvas();
    this.ctx = this.canvas.getContext('2d');
    this.loadFishImage();
  }

  loadFishImage() {
    this.fishImage = wx.createImage();
    this.fishImage.src = 'images/test.png';

    this.fishImage.onload = () => {
      this.createFishes(5);
      this.startAnimation();
    };

    this.fishImage.onerror = () => {
      this.createFishes(3);
      this.startAnimation();
    };
  }

  createFishes(count) {
    for (let i = 0; i < count; i++) {
      this.createFish();
    }
  }

  createFish() {
    const maxX = Math.max(0, this.canvas.width - FISH_CONFIG.width);
    const maxY = Math.max(0, this.canvas.height - FISH_CONFIG.height);
    const x = Math.floor(Math.random() * maxX);
    const y = Math.floor(Math.random() * maxY);
    const direction = Math.random() < 0.5 ? -1 : 1;

    const fish = new Fish(this.fishImage, x, y, direction);
    this.fishes.push(fish);
  }

  startAnimation() {
    const animate = (timestamp) => {
      this.update();
      this.render();
      requestAnimationFrame(animate);
    };
    requestAnimationFrame(animate);
  }

  update() {
    const time = Date.now() / 500;
    this.fishes.forEach(fish => {
      fish.update(this.canvas.width, this.canvas.height);
    });
  }

  render() {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.fillStyle = '#87CEEB';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

    const time = Date.now() / 500;
    this.fishes.forEach(fish => {
      fish.draw(this.ctx, time);
    });
  }
}

const fishTank = new FishTank();
fishTank.init();

































